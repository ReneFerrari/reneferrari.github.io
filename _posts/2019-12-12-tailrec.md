---
layout: post
title:  [WIP] tailrec 🐈
date:   2019-12-12
excerpt: tailrec 🐈
---
## Introduction
`tailrec` is a keyword which enables optimization of tail recursive functions. These are functions that have a recursive call as their last statement. Instead of creating a new stack entry for each recursive call, functions marked as tailrec "reuse" the existing one. 

 A simple example:

{% highlight kotlin %}
tailrec fun factorial(start: Int, accumulator: Int = 1): Int = when (start) {
    1 -> accumulator
    else -> factorial(start - 1, accumulator * start)
}
{% endhighlight %}

## Comparison to a regular recursive function
The previously shown function could be written without tailrec - like this:

{% highlight kotlin %}
fun factorialRegular(start: Int, accumulator: Int = 1): Int = when (start) {
    1 -> accumulator
    else -> factorialRegular(start - 1, accumulator * start)
}
{% endhighlight %}

To understand how the tailrec version is "reusing" the stack entry we must take a look at the bytecode decompiled to Java:

{% highlight kotlin %}
// tailrec version
public static final int factorial(int start, int accumulator) {
    while(true) {
        switch(start) {
        case 1:
        return accumulator;
        default:
        int var10000 = start - 1;
        accumulator *= start;
        start = var10000;
        }
    }
}
{% endhighlight %}

{% highlight kotlin %}
// regular version
public static final int factorialRegular(int start, int accumulator) {
    int var10000;
    switch(start) {
    case 1:
        var10000 = accumulator;
        break;
    default:
        var10000 = factorialRegular(start - 1, accumulator * start);
    }

    return var10000;
}
{% endhighlight %}

You will immediately notice that a function marked as tailrec is actually not recursive (on a decompiled Java code level).
Instead the whole magic behind it is just an endless while loop.

## More in depth
What I have already explained should be sufficient knowledge for day to day programming. However there are still some unanswered questions:
- Why doesn't the compiler automatically optimize tailrec functions?
- Why has the return type ((even for such a simple example like factorial calculation) be specified explicitly?
- Why doesn't Java support tailrec?
- Why is a while(true) loop used instead of clearing the callstack?
- What is mutual tail recursion?
- Why doesn't Kotlin support mutual tail recursion?

### Why doesn't the compiler automatically optimize tailrec?
I am just going to quote Roman Elizarov from the Jetbrains team:
> Implicit tailrec optimization is very fragile and error-prone. People make mistakes and tailrec modifier is here to explicitly declare programmer’s intent to define a tailrec function. You (as a programmer) declare your intent and compiler verifies it. It also serves as a helpful piece of documentation for future readers and maintainers of your code. If they accidentally break it, they’ll get caught by compiler.

### Why has the return type be specified explicitly?
One word: Speed. 

With a more complicated type inference the compiler could figure out the return type, but unfortunately this would cause the compilation process
to be a lot slower.

### Why doesn't Java support tailrec?
