<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"> <title>tailrec üêà &#8211; Rene Ferrari</title> <meta name="description" content="tailrec üêà"> <meta name="keywords" content=""> <!-- Twitter Cards --> <meta name="twitter:card" content="summary"> <meta name="twitter:image" content="avatar.jpg"> <meta name="twitter:title" content="tailrec üêà"> <meta name="twitter:description" content="tailrec üêà"> <!-- Open Graph --> <meta property="og:locale" content="en_US"> <meta property="og:type" content="article"> <meta property="og:title" content="tailrec üêà"> <meta property="og:description" content="tailrec üêà"> <meta property="og:url" content="http://localhost:4000/tailrec/"> <meta property="og:site_name" content="Rene Ferrari"> <meta property="og:image" content="http://localhost:4000/images/avatar.jpg"> <link rel="canonical" href="http://localhost:4000/tailrec/"> <!-- Handheld --> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Feed --> <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Rene Ferrari" /> <!-- CSS --> <link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/main.css"> <!-- Left Block Image for Posts --> <style type="text/css"> #posts.inner-post-page .block-left {background: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url(http://localhost:4000/) no-repeat;background-size: cover;} </style> <!-- Left Block Images for Home and Pages --> <style type="text/css"> #posts .block-left {background: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url(http://localhost:4000/) no-repeat;background-size: cover, cover;} .block-left {background: linear-gradient(rgba(28, 28, 28, 0.75), rgba(48, 48, 48, 0.75)), url(http://localhost:4000/images/home.jpg) no-repeat;background-size: cover;} </style> </head> <body id="posts" class="inner-post-page" style="background: #ececec52;"> <div style="overflow-y:auto; height: 100%;"> <a href="http://localhost:4000"> <h3 style="margin-left: 56px;">Home</h3> </a> <div class="inner-post content-post" style="padding-top: 0px;"> <h1 style="text-align: center;">tailrec üêà </h1> <div class="date-highlight">13 Aug 2020</div> <h2 id="introduction">Introduction</h2> <p><code class="highlighter-rouge">tailrec</code> is a keyword which enables the optimization of tail recursive functions. A tail recursive function is defined by having a recursive call as it‚Äôs last executable statement. Instead of creating a new stack entry for each recursive call, functions marked as tailrec ‚Äúreuse‚Äù the existing one. Therefore saving you from a possible stack overflow (if you would make a lot of recursive calls) and keeping your allocated memory lower. It is important to note that the JVM does not support proper tail recursion - Kotlin solves this by using trampolining (as we will see later).</p> <p>A simple example:</p> <figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">tailrec</span> <span class="k">fun</span> <span class="nf">factorialRegular</span><span class="p">(</span><span class="nv">start</span><span class="p">:</span> <span class="nc">Int</span><span class="p">,</span> <span class="nv">accumulator</span><span class="p">:</span> <span class="nc">Int</span> <span class="p">=</span> <span class="m">1</span><span class="p">):</span> <span class="nc">Int</span> <span class="p">=</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="p">==</span> <span class="m">1</span><span class="p">)</span> <span class="n">accumulator</span>
    <span class="k">else</span> <span class="n">factorialRegular</span><span class="p">(</span><span class="n">start</span> <span class="p">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">accumulator</span> <span class="p">*</span> <span class="n">start</span><span class="p">)</span></code></pre></figure> <h2 id="comparison-to-a-regular-recursive-function">Comparison to a regular recursive function</h2> <p>The previously shown function could be written without tailrec - like this:</p> <figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">fun</span> <span class="nf">factorialRegular</span><span class="p">(</span><span class="nv">start</span><span class="p">:</span> <span class="nc">Int</span><span class="p">,</span> <span class="nv">accumulator</span><span class="p">:</span> <span class="nc">Int</span> <span class="p">=</span> <span class="m">1</span><span class="p">):</span> <span class="nc">Int</span> <span class="p">=</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="p">==</span> <span class="m">1</span><span class="p">)</span> <span class="n">accumulator</span>
    <span class="k">else</span> <span class="n">factorialRegular</span><span class="p">(</span><span class="n">start</span> <span class="p">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">accumulator</span> <span class="p">*</span> <span class="n">start</span><span class="p">)</span></code></pre></figure> <p>To understand how the tailrec version is ‚Äúreusing‚Äù the stack entry we must take a look at the bytecode decompiled to Java:</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// regular version</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">factorialRegular</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">accumulator</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">start</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">accumulator</span> <span class="o">:</span> <span class="n">factorialRegular</span><span class="o">(</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">accumulator</span> <span class="o">*</span> <span class="n">start</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure> <p>The non-tailrec version is basically how you would write it in Java - there is nothing special here. Now let‚Äôs take a look at the tailrec version:</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// tailrec version</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">factorialRegular</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">accumulator</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span><span class="o">(</span><span class="n">start</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">var10000</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">accumulator</span> <span class="o">*=</span> <span class="n">start</span><span class="o">;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">var10000</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">accumulator</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure> <p>This version eliminates recursion by wrapping everything in a while loop. This is - to my understanding - a form of trampolining (explained in the section <a href="#mutual-tail-recursion">‚ÄúWhy doesn‚Äôt Kotlin support mutual tail recursion?‚Äù</a>). What‚Äôs interesting is how recursion is avoided:</p> <figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="c1">//recursive call</span>
<span class="n">factorial</span><span class="p">(</span><span class="n">start</span> <span class="p">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">accumulator</span> <span class="p">*</span> <span class="n">start</span><span class="p">)</span></code></pre></figure> <p>becomes</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="k">while</span><span class="o">(</span><span class="n">start</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">var10000</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="n">accumulator</span> <span class="o">*=</span> <span class="n">start</span><span class="o">;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">var10000</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure> <p>To keep it simple: tailrec just leads to a ‚Äúrewrite‚Äù of the function from a recursive to an imperative manner.</p> <h2 id="more-in-depth">More in depth</h2> <p>What I have already explained should be sufficient knowledge for day to day programming. However there are still some unanswered questions:</p> <ul> <li>Why doesn‚Äôt the compiler automatically optimize tailrec functions (without the need for the keyword)?</li> <li>Why has the return type (even for such a simple example like factorial calculation) be specified explicitly?</li> <li>Why doesn‚Äôt Java support tailrec?</li> <li>What is mutual tail recursion?</li> <li>Why doesn‚Äôt Kotlin support mutual tail recursion?</li> </ul> <h3 id="why-doesnt-the-compiler-automatically-optimize-tailrec-functions">Why doesn‚Äôt the compiler automatically optimize tailrec functions?</h3> <p>I am just going to quote Roman Elizarov from the Jetbrains team:</p> <blockquote> <p>Implicit tailrec optimization is very fragile and error-prone. People make mistakes and tailrec modifier is here to explicitly declare programmer‚Äôs intent to define a tailrec function. You (as a programmer) declare your intent and compiler verifies it. It also serves as a helpful piece of documentation for future readers and maintainers of your code. If they accidentally break it, they‚Äôll get caught by compiler.</p> </blockquote> <h3 id="why-has-the-return-type-be-specified-explicitly">Why has the return type be specified explicitly?</h3> <p>One word: Speed.</p> <p>With a more complicated type inference system the compiler could figure out the return type, but unfortunately this would cause the compilation process to be a lot slower.</p> <h3 id="why-doesnt-java-support-tailrec">Why doesn‚Äôt Java support tailrec?</h3> <p>I will reference directly to this question on the softwareengineering stackexchange: <a href="https://softwareengineering.stackexchange.com/questions/272061/why-doesnt-java-have-optimization-for-tail-recursion-at-all">‚ÄúWhy doesn‚Äôt Java have optimization for tail-recursion at all?‚Äù</a>.</p> <p>The user <code class="highlighter-rouge">ggovan</code> gave a very concise answer:</p> <blockquote> <p>As explained by Brian Goetz (Java Language Architect at Oracle) in this <a href="https://www.youtube.com/watch?v=2y5Pv4yN0b0&amp;t=1h02m18s">video</a>: ‚ÄúIn jdk classes [‚Ä¶] there are a number of security sensitive methods that rely on counting stack frames between jdk library code and calling code to figure out who‚Äôs calling them‚Äù.</p> <p>Anything that changed the number of frames on the stack would break this and would cause an error. He admits this was a stupid reason, and so the JDK developers have since replaced this mechanism. He further then mentions that it‚Äôs not a priority, but that tail recursion ‚Äúwill eventually get done‚Äù. N.B. This applies to HotSpot and the OpenJDK, other VMs may vary.</p> </blockquote> <h3 id="what-is-mutual-tail-recursion">What is mutual tail recursion?</h3> <p>I really like the following explanation (for more in depth info you can <a href="https://www.cs.bu.edu/~hwxi/ATS/DOCUMENT/TUTORIALATS/HTML/c244.html">visit the site</a>):</p> <blockquote> <p>Mutually tail-recursive functions are commonly encountered in practice. Assume that foo and bar are two mutually defined functions. In the body of either foo or bar, a tail-call to foo or bar is referred to as a mutually tail-recursive call. If every call to foo or bar in the bodies of foo and bar are tail-call, then foo and bar are mutually tail-recursive. Mutual recursion involving more functions can be defined similarly.</p> </blockquote> <h3 id="-why-doesnt-kotlin-support-mutual-tail-recursion"><a name="mutual-tail-recursion"></a> Why doesn‚Äôt Kotlin support mutual tail recursion?</h3> <p>Someone on SO asked exactly that. The <a href="https://stackoverflow.com/a/44626117/8011713">answer</a> given by <code class="highlighter-rouge">comonad</code> is a very good explanation in my opinion.</p> <blockquote> <p>What you are looking for are ‚Äúproper tail calls‚Äù. The JVM does not support those, so you need <a href="https://en.wikipedia.org/wiki/Tail_call#Through_trampolining">trampolines</a>. A proper tail call cleans up the memory of its own function (parameters, local variables) before jumping (instead of calling) to the tail called function. That way the tail called function can return directly to its caller-caller-function.</p> <p>Infinite mutual recursion is possible. (In functional languages this is one of the most important features.) To allow proper tail calls in assembler you would need a command to jump (goto) to a routine/method that is referred to via pointer. OOP needs calls (stores location to jump back to on the stack and then jumps) to a routine/method that is referred to via pointer.</p> <p>You can emulate proper tail calls with the trampoline design pattern, maybe there is some support via library. The trampoline is a while loop that calls a function which returns a reference to the next function which returns a reference to the next‚Ä¶</p> </blockquote> </div> <!-- JS --> <script src="http://localhost:4000/assets/js/main.min.js"></script> <div class="overlay"> <ul class="projects-menu"> <li style="background:url(http://taylantatli.me/Halve/images/halve-home-image.png) center center no-repeat;"> <a href="http://taylantatli.me/Halve" class="inactive" target="_blank" rel="nofollow external"> <span> Halve Jekyll Theme <br><em>in progress</em> </span> </a> </li> <li style="background:url(https://cloud.githubusercontent.com/assets/754514/14509720/61c61058-01d6-11e6-93ab-0918515ecd56.png) center center no-repeat;"> <a href="http://taylantatli.me/Moon" target="_blank" rel="nofollow external"> <span> Moon Jekyll Theme </span> </a> </li> <li style="background:url(https://raw.githubusercontent.com/TaylanTatli/Ramme/master/assets/img/screenshot-post.png) center center no-repeat;"> <a href="http://taylantatli.me/Ramme" target="_blank" rel="nofollow external"> <span> Ramme Jekyll Theme </span> </a> </li> <li style="background:url(https://raw.githubusercontent.com/TaylanTatli/Daisy-Pelican-Theme/master/Preview-1.png) center center no-repeat;"> <a href="http://taylantatli.me/Daisy-Pelican-Theme/" target="_blank" rel="nofollow external"> <span> Daisy Pelican Theme </span> </a> </li> <li style="background:url(https://raw.githubusercontent.com/TaylanTatli/Block-Icon-Theme/master/Preview.png) center center no-repeat;"> <a href="https://github.com/TaylanTatli/Block-Icon-Theme" class="inactive" target="_blank" rel="nofollow external"> <span> Block Icon Theme <br><em>in progress</em> </span> </a> </li> <li style="background:url(https://raw.githubusercontent.com/TaylanTatli/StartPage/master/preview.png) center center no-repeat;"> <a href="http://taylantatli.me/StartPage/" class="inactive" target="_blank" rel="nofollow external"> <span> Start Page <br><em>in progress</em> </span> </a> </li> </ul> </div> </div> </body> </html>
